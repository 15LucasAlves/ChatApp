package com.example.chatapp.ui.users

import android.util.Log
import androidx.compose.runtime.mutableStateOf
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.chatapp.data.model.User
import com.example.chatapp.data.repository.UserRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

/**
 * ViewModel for the user selection screen in the chat app.
 * This ViewModel is responsible for managing the state of the user selection screen,
 * including the list of users, the current user's email, the recipient's email, and any errors that occur.
 */
class UserSelectionViewModel : ViewModel() {
    // Inject the UserRepository to fetch user data
    private val repository = UserRepository()

    // MutableStateFlow to hold the list of users
    private val _users = MutableStateFlow<List<User>>(emptyList())
    val users: StateFlow<List<User>> = _users

    // MutableStateFlow to hold any errors that occur
    private val _error = MutableStateFlow("")
    val error: StateFlow<String> = _error

    // MutableState to hold the current user's email
    private val _currentUserEmail = mutableStateOf("")
    val currentUserEmail: String get() = _currentUserEmail.value

    // MutableState to hold the recipient's email
    private val _currentRecipientEmail = mutableStateOf("")
    val recipientEmail: String get() = _currentRecipientEmail.value

    // List to hold all the users
    private var allUsers: List<User> = listOf()

    /**
     * Loads the list of users from the UserRepository, excluding the current user.
     * @param currentUserEmail the email of the current user
     */
    fun loadUsers(currentUserEmail: String) {
        viewModelScope.launch {
            try {
                repository.getAllUsers().collect { usersList ->
                    allUsers = usersList.filter { it.email != currentUserEmail }
                    _users.value = allUsers
                }
            } catch (e: Exception) {
                _error.value = "Failed to load users: ${e.message}"
            }
        }
    }

    /**
     * Searches the list of users based on the provided query.
     * If the query is empty, it displays the full list of users.
     * Otherwise, it filters the list to only include users whose email or username contains the query.
     * @param query the search query
     */
    fun searchUsers(query: String) {
        if (query.isEmpty()) {
            _users.value = allUsers
        } else {
            _users.value = allUsers.filter { user ->
                user.email.contains(query, ignoreCase = true) ||
                        user.username?.contains(query, ignoreCase = true) == true
            }
        }
    }

    /**
     * Generates a unique chat ID based on the current user's email and the recipient's email.
     * The chat ID is generated by sorting the emails and concatenating them with a hyphen.
     * @param currentUserEmail the email of the current user
     * @param recipientEmail the email of the recipient
     * @return the generated chat ID
     */
    fun chatId(currentUserEmail: String, recipientEmail:String):String{
        val sortedEmails = listOf(currentUserEmail, recipientEmail).sorted()
        val chatId = "${sortedEmails[0]}-${sortedEmails[1]}"
        Log.d("UserSelect", chatId)
        return chatId
    }
}